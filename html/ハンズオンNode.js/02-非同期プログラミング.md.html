<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.13.2/dist/style.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.13.2"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.13.2/dist/index.umd.min.js"></script><script>(r => {
          setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(markmap, jsonOptions), root);
      })(() => window.markmap,(markmap, jsonOptions) => markmap.deriveOptions(jsonOptions),{"type":"heading","depth":1,"payload":{"lines":[0,1]},"content":"非同期プログラミング","children":[{"type":"heading","depth":2,"payload":{"lines":[2,3]},"content":"イベントループと非同期プログラミング_","children":[{"type":"heading","depth":3,"payload":{"lines":[3,4]},"content":"マルチスレッドによる並行処理とのその問題点","children":[{"type":"list_item","depth":5,"payload":{"lines":[4,5]},"content":"C10K問題","children":[{"type":"paragraph","depth":7,"payload":{"lines":[5,7]},"content":"(p.41)<br>\n同時接続するクライアント数が 10,000 程度まで増えると、レスポンス性能が著しく劣化してしまうこと"}]},{"type":"list_item","depth":5,"payload":{"lines":[7,8]},"content":"コンテキストスイッチ_"},{"type":"list_item","depth":5,"payload":{"lines":[8,9]},"content":"スレッドセーフ_","children":[{"type":"paragraph","depth":7,"payload":{"lines":[9,11]},"content":"(p.41)<br>\nあるコードを複数のスレッドが並行に実行しても問題が発生しないこと"}]}]},{"type":"heading","depth":3,"payload":{"lines":[12,13]},"content":"イベントループによる並行処理と非同期プログラミング_","children":[{"type":"list_item","depth":5,"payload":{"lines":[13,14]},"content":"非同期処理と非同期プログラミング","children":[{"type":"paragraph","depth":7,"payload":{"lines":[14,17]},"content":"(p.43)<br>\nその完了を待機せずに次に進んでしまうような処理を非同期処理、<br>\nそのような処理を使ってプログラムを記述することを非同期プログラミングと呼びます。"}]},{"type":"list_item","depth":5,"payload":{"lines":[17,18]},"content":"イベントループで注意すべき点_","children":[{"type":"list_item","depth":7,"payload":{"lines":[18,19]},"content":"非同期プログラミングの複雑さ"},{"type":"list_item","depth":7,"payload":{"lines":[19,20]},"content":"CPU負荷の高い処理の扱い","children":[{"type":"list_item","depth":9,"payload":{"lines":[20,21]},"content":"I/Oを多用するようなアプリケーションの開発には適している"},{"type":"list_item","depth":9,"payload":{"lines":[21,22]},"content":"キューに入ったタスクを順番に処理するため、CPU負荷の高い処理があると待ちが発生する"},{"type":"list_item","depth":9,"payload":{"lines":[22,23]},"content":"Node.js はマルチスレッドによる並行処理も可能_"}]}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[25,26]},"content":"コールバック","children":[{"type":"heading","depth":3,"payload":{"lines":[26,27]},"content":"コールバックを利用した非同期APIを実行する","children":[{"type":"list_item","depth":5,"payload":{"lines":[27,28]},"content":"Node.js のコールバックによる非同期処理の実装規約_","children":[{"type":"paragraph","depth":7,"payload":{"lines":[28,31]},"content":"(p.48)<br>\n・コールバックがパラメータの最後にあること<br>\n・コールバックの最初のパラメータが処理中に発生したエラー、2つ目以降のパラメータが処理の結果であること"}]}]},{"type":"heading","depth":3,"payload":{"lines":[32,33]},"content":"エラーハンドリング","children":[{"type":"list_item","depth":5,"payload":{"lines":[33,34]},"content":"エラーがイベントループまで到達すると <code>uncaughtException</code> イベントが発生し、アプリが停止する_"},{"type":"list_item","depth":5,"payload":{"lines":[34,35]},"content":"コールバックの中で起こりうる例外は、それを受け取る関数の中で適切に処理すべし_"}]},{"type":"heading","depth":3,"payload":{"lines":[36,37]},"content":"混ぜるな危険、同期と非同期","children":[{"type":"list_item","depth":5,"payload":{"lines":[37,38]},"content":"JavaScript のアンチパターン_"},{"type":"list_item","depth":5,"payload":{"lines":[38,39]},"content":"コールバックを同期的に実行したり非同期的に実行したりするのはＮＧ","children":[{"type":"paragraph","depth":7,"payload":{"lines":[39,42]},"content":"(p.53)<br>\nコールバックをパラメータとする関数は、それを常に同期的に実行するか、<br>\n常に非同期的に実行するかのどちらかでなければなりません。"}]},{"type":"list_item","depth":5,"payload":{"lines":[42,43]},"content":"呼び出し方に一貫性がないと API の挙動が予測しづらくなる"},{"type":"list_item","depth":5,"payload":{"lines":[43,44]},"content":"イベントループの 6 つのフェーズ_","children":[{"type":"list_item","depth":7,"payload":{"lines":[44,45]},"content":"timers"},{"type":"list_item","depth":7,"payload":{"lines":[45,46]},"content":"pending callback"},{"type":"list_item","depth":7,"payload":{"lines":[46,47]},"content":"idle prepare"},{"type":"list_item","depth":7,"payload":{"lines":[47,48]},"content":"poll"},{"type":"list_item","depth":7,"payload":{"lines":[48,49]},"content":"check"},{"type":"list_item","depth":7,"payload":{"lines":[49,50]},"content":"close callbacks"}]},{"type":"list_item","depth":5,"payload":{"lines":[50,51]},"content":"<code>nextTickQueue</code> に積まれたコールバックは現在実行中の処理が完了次第すぐに実行される"},{"type":"list_item","depth":5,"payload":{"lines":[51,52]},"content":"<code>microTaskQueue</code> も同様 (ECMAScript標準の Promise を使った場合の格納先)"},{"type":"list_item","depth":5,"payload":{"lines":[52,53]},"content":"<code>nextTickQueue</code> や <code>microTaskQueue</code> の多用は要注意","children":[{"type":"paragraph","depth":7,"payload":{"lines":[53,59]},"content":"(p.57)<br>\nイベントループのフェーズの中で実行されるコールバックは<br>\n一度に実行できる回数が制限されていますが、<br>\nnextTickQueue や microTaskQueue にはそのような制限がありません。<br>\nこのため、たとえば process.nextTick() を再帰的に実行し続けるようなコードを書くと、<br>\nイベントループが停止して I/Oのコールバックなどを実行できなくなってしまいます。"}]}]}]}]},null)</script>
</body>
</html>
